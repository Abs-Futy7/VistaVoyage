from typing import Optional, List, Dict, Any
from sqlmodel.ext.asyncio.session import AsyncSession
from sqlmodel import select, func
from fastapi import HTTPException, UploadFile
from ..models.blog import Blog
from ..schemas.blog_schemas import BlogCreateModel, BlogUpdateModel
from .supabase_service import supabase_service
import uuid


class BlogService:
    
    async def get_blogs(
        self,
        session: AsyncSession,
        page: int = 1,
        limit: int = 10,
        search: Optional[str] = None,
        category: Optional[str] = None,
        published_only: bool = False
    ) -> dict:
        """Get paginated list of blogs with author name included"""
        from src.auth.models import User

        # Build base query and apply filters
        base_query = select(Blog, User.full_name).join(User, Blog.author_id == User.uid)
        if search:
            base_query = base_query.where(Blog.title.contains(search))
        if category:
            base_query = base_query.where(Blog.category == category)
        if published_only:
            from ..models.blog import BlogStatus
            base_query = base_query.where(Blog.status == BlogStatus.PUBLISHED)

        # Count query (no offset/limit/order_by)
        count_query = select(func.count()).select_from(base_query.subquery())
        total_result = await session.exec(count_query)
        total = total_result.first()
        if isinstance(total, tuple):
            total = total[0]

        # Now apply pagination to a new query
        offset = (page - 1) * limit
        paged_query = base_query.offset(offset).limit(limit).order_by(Blog.created_at.desc())
        result = await session.exec(paged_query)
        blog_rows = result.all()

        # Build blogs list with author_name
        blogs = []
        for blog, author_name in blog_rows:
            blog_dict = blog.dict() if hasattr(blog, 'dict') else dict(blog)
            blog_dict['author_name'] = author_name
            blogs.append(blog_dict)

        return {
            "blogs": blogs,
            "total": total,
            "page": page,
            "limit": limit,
            "total_pages": (total + limit - 1) // limit if total else 0
        }
    
    async def get_blog_by_id_raw(self, session: AsyncSession, blog_id: str) -> Optional[Blog]:
        """Get a single blog by ID without author name (for internal operations)"""
        try:
            # Convert string to UUID
            blog_uuid = uuid.UUID(blog_id)
            query = select(Blog).where(Blog.id == blog_uuid)
            result = await session.exec(query)
            return result.first()
        except ValueError:
            # Invalid UUID format
            return None
    async def get_blog_by_id(self, session: AsyncSession, blog_id: str) -> Optional[dict]:
        """Get a single blog by ID with author name"""
        from src.auth.models import User
        
        try:
            # Convert string to UUID
            blog_uuid = uuid.UUID(blog_id)
            
            # Query with join to get author name
            query = select(Blog, User.full_name).join(User, Blog.author_id == User.uid).where(Blog.id == blog_uuid)
            result = await session.exec(query)
            blog_row = result.first()
            
            if not blog_row:
                return None
            
            blog, author_name = blog_row
            
            # Convert to dict and add author_name
            blog_dict = blog.dict() if hasattr(blog, 'dict') else dict(blog)
            blog_dict['author_name'] = author_name
            
            return blog_dict
            
        except ValueError:
            # Invalid UUID format
            return None
    
    async def create_blog(
        self, 
        session: AsyncSession, 
        blog_data: BlogCreateModel,
        cover_image: Optional[UploadFile] = None
    ) -> Blog:
        """Create a new blog post"""
        
        # Handle image upload if provided
        cover_image_url = None
        if cover_image:
            cover_image_url = await supabase_service.upload_blog_image(cover_image)
        
        # Create blog data dict (UUID will be auto-generated by the model)
        blog_dict = blog_data.model_dump()
        
        if cover_image_url:
            blog_dict["cover_image"] = cover_image_url
        
        # Create and save blog
        new_blog = Blog(**blog_dict)
        session.add(new_blog)
        await session.commit()
        await session.refresh(new_blog)
        
        return new_blog
    
    async def update_blog(
        self,
        session: AsyncSession,
        blog_id: str,
        blog_data: BlogUpdateModel,
        cover_image: Optional[UploadFile] = None
    ) -> Optional[Blog]:
        """Update an existing blog post"""
        
        # Get existing blog using raw method
        blog = await self.get_blog_by_id_raw(session, blog_id)
        if not blog:
            return None
        
        # Handle new image upload
        if cover_image:
            # Delete old image if exists
            if blog.cover_image:
                await supabase_service.delete_blog_image(blog.cover_image)
            
            # Upload new image
            new_cover_image_url = await supabase_service.upload_blog_image(cover_image)
            blog.cover_image = new_cover_image_url
        
        # Update blog fields
        update_data = blog_data.model_dump(exclude_unset=True, exclude_none=True)
        for field, value in update_data.items():
            if hasattr(blog, field):
                setattr(blog, field, value)
        
        # Save changes
        session.add(blog)
        await session.commit()
        await session.refresh(blog)
        
        return blog
    
    async def delete_blog(self, session: AsyncSession, blog_id: str) -> bool:
        """Delete a blog post"""
        
        blog = await self.get_blog_by_id_raw(session, blog_id)
        if not blog:
            return False
        
        # Delete image from storage if exists
        if blog.cover_image:
            await supabase_service.delete_blog_image(blog.cover_image)
        
        # Delete blog from database
        await session.delete(blog)
        await session.commit()
        
        return True
    
    async def toggle_publish_status(self, session: AsyncSession, blog_id: str) -> Optional[Blog]:
        """Toggle the publish status of a blog"""
        from ..models.blog import BlogStatus
        from datetime import datetime
        
        blog = await self.get_blog_by_id_raw(session, blog_id)
        if not blog:
            return None

        if blog.status == BlogStatus.PUBLISHED:
            blog.status = BlogStatus.DRAFT
            blog.published_at = None
        else:
            blog.status = BlogStatus.PUBLISHED
            blog.published_at = datetime.now()

        session.add(blog)
        await session.commit()
        await session.refresh(blog)
        
        return blog
    
    async def get_blog_stats(self, session: AsyncSession) -> Dict[str, Any]:
        """Get blog statistics for admin dashboard"""
        from ..models.blog import BlogStatus
        
        # Total blogs
        total_query = select(func.count(Blog.id))
        total_result = await session.exec(total_query)
        total_blogs = total_result.one()
        
        # Published blogs
        published_query = select(func.count(Blog.id)).where(Blog.status == BlogStatus.PUBLISHED)
        published_result = await session.exec(published_query)
        published_blogs = published_result.one()
        
        # Draft blogs
        draft_query = select(func.count(Blog.id)).where(Blog.status == BlogStatus.DRAFT)
        draft_result = await session.exec(draft_query)
        draft_blogs = draft_result.one()
        
        # Blogs by category
        category_query = select(Blog.category, func.count(Blog.id)).group_by(Blog.category)
        category_result = await session.exec(category_query)
        blogs_by_category = {category: count for category, count in category_result.all() if category}
        
        return {
            "total_blogs": total_blogs,
            "published_blogs": published_blogs,
            "draft_blogs": draft_blogs,
            "blogs_by_category": blogs_by_category
        }

# Create singleton instance
blog_service = BlogService()
